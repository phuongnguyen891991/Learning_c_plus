= C++ definition
:sectnums: all
:sectnumlevels: 5
:toc: left
:toclevels: 9
:toc-title: Content

:description: Example AsciiDoc document
:keywords: AsciiDoc
:imagesdir: ./images
---

== Definition
Các chuẩn giao tiếp:

I2C là gì ?

CAN là gì ?

I2S là gì ?

SPI là gì ?



== CODE FOR WIN
== C compilation
. Một chương trình C khi build thì trải qua 4 giai đoạn tương ứng như sau:
.. Pre-processing (tiền xử lý)
.. Compilation
.. Assembling
.. Linking
+
image::c-compilation-process.png[,400,200]

* Để dễ hiểu, chúng ta phân tích ví dụ sau đây
+
.Example
[source, c]
----
/* Learning C compilation process */ --->> comment code
#include <stdio.h> --->> pre-processor directive

int main() --->> main function
{
    printf("Learn at Codeforwin!"); --->> function
    return 0;
}
----

** Ở ví dụ trên, một chương trình đơn giản sẽ được xử lý và tạo thành các file như sau:
+
.Output file
[source, shell]
----
hello.c (Generated by pre-processor)
hello.i (Generated by compiler)
hello.o (Generated by assembler)
hello.s (On Linux Generated by linker) or (compilation.exe On Windows)
----

.. *Pre-processing of source file*
+
* xóa comments bên trong source code.
* Triển khai các marcro
* Triển khai các header.
+
[NOTE]
====
* Sau bước pre-processing, nó sẽ sinh ra *file.i*, vì nó *_chèn_* thêm nội dung của file header vào source code.
====

.. *Biên dịch của file pre-processed (file tiền xử lý)* (tạm dịch là biên dịch file tiền xử lý)
* Quá trình này chấp nhận file *file.i* như input và bắt đầu thực hiện các steps
** Kiểm tra *_lỗi cú pháp_* sử dụng trong C
** Chuyển đổi file thành intermediate code (_*file.i.e*_) trong ngôn ngữ assembly.
** Thực hiện tối ưu hóa code để có performance tốt hơn.

.. *Tập hợp (assembling) mã nguồn biên dịch*
* Trình hợp ngữ (assembler) sử dụng code đã biên dịch và phiên dịch thành ngôn ngữ cấp thấp, quá trình này thành công thì sẽ tạo ra *file.o*

.. *Linking*
* Ở bước cuối cùng này, *_trình liên kết_* (linker) sẽ tiến hành xử lý *file.o*. Nó sẽ liên kết tất cả các function call đã được define hoặc gọi từ các libs.
* Trình liên kết sẽ tạo ra file thực thi.


== Cross compile



== Implicit typecasting (Ép kiểu ngầm định trong compiler)
* Là quá trình chuyển đổi được thực hiện tự động bởi trình biên dịch.
* Việc này được thực hiện khi muốn chuyển một kiểu dữ liệu nhỏ sang kiểu dữ liệu lớn.
* Ví dụ đoạn code sau:
+
[source, c]
----
    #include <stdio.h>

    int main() {
    int a = 10;
    float b = a;  // ép kiểu int sang float
    printf("a = %d\n", a);
    printf("b = %f", b);
}
----

=== interger promotion (Thăng cấp số nguyên)
* Là quá trình mà giá trị của kiểu số nguyên *_nhỏ hơn_* *_INT_* hoặc *_UNSIGN INT_* sẽ được chuyển đổi thành *_INT_* hoặc *_UNSIGN INT_*
* Nếu các toán tử có kiểu dữ liệu khác nhau thì chúng sẽ được chuyển đổi thành kiểu cao nhất trong sơ đồ phân cấp.
+
image::usual-arithmetic-conversion.png[,200,100]

== Explicit typecasting (Ép kiểu tường minh)
. Syntax: *_(new-type) <variable-expression-literal>_* -> *_new-type_* is a valid C data type.

* Được thực hiện một cách rõ ràng từ yêu cầu của dev, bằng cách thực hiện toán tử để  thực hiện việc ép kiểu.
* ví dụ đoạn code như sau:
+
[source, c, subs="verbatim,quotes"]
----
#include <stdio.h>

int main()
{
    float average = 0;
    int num1, num2, num3;

    num1 = 91;
    num2 = 85;
    num3 = 83;

    *_average = (float)(num1 + num2 + num3) / 3;_*

    printf("Average: %f \n", average);
    return 0;
}
----

== Function
* Lợi ích của việc viết hàm:
** Tái sử dụng lại code.
** Function được trừu tượng hóa hoặc được "chiết" nhỏ.
** Function cho phép thiết kế theo dạng module.
** Dễ dàng viết chương trình.
** Dễ dàng maintain và debug code.

* Syntax khai báo hàm *_return_type function_name (parameter list)_*

* Trong lập trình C, có thể  truyền giá trị đến function theo 2 cách:
** truyền giá trị (call by value).
** Truyền tham chiếu (call by preference).

.. *Truyền giá trị của biến*
*** là cơ chế mặc định để pass argument tới hàm. trong khi gọi hàm, biến truyền vào (input parameter) được sao chép và chuyển sang biến bên trong hàm con. Những thay đổi về giá trị của biến trong hàm con không ảnh hưởng đến giá trị của biến được truyền vào.

.. *Truyền tham chiếu của biến*
*** là chuyển vị trí của bộ nhớ (preference) của tham số hiện tại sang tham số của hàm. Pointer (con trỏ) sẽ được sử dụng trong trường hợp này và những thay đổi của biến trong hàm sẽ ảnh hưởng ngay lập tức đến biến input.

* Đối với fuction sẽ có 2 loại chính
** Library function
** User defined functions (gồm 4 loại)
.. Function không không có giá trị trả về và không có tham số truyền vào (argument).
.. Function không có giá trị trả về nhưng có argument.
.. Function có giá trị trả về nhưng không có argument.
.. Function có giá trị trả về và có cả argument.

== Hàm đệ quy
* Một hàm được gọi là đệ quy nếu trong hàm có một hoặc nhiều lệnh gọi đến chính hàm đó.
* Tương tự như các vòng lặp, nó phải xác định được điểm dừng, nếu không bài toán sẽ lặp vĩnh cửu.
* Đệ quy gồm 2 phần:
.. base case
.. recursive case

=== Hàm đệ quy hoạt động như thế nào ?
[source, shell]
----
include::example/recursion_example.c[indent=1]
----

* Cơ chế hoạt động của *_Đệ quy_* tuân thủ theo nguyên tắc LIFO (Last Int Firt Out) hay còn gọi là cơ chế *_stack_*.
+
image::last-in-first-out.png[,400,200]
+
[source, shell]
----
include::example/fibonacci_recursive.c[indent=1]
----

== Design pattern

===